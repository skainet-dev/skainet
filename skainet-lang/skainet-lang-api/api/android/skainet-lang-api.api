public final class sk/ainet/lang/tensor/ContiguityAnalysis {
	public fun <init> (ZIIDLjava/util/List;Ljava/lang/String;)V
	public final fun component1 ()Z
	public final fun component2 ()I
	public final fun component3 ()I
	public final fun component4 ()D
	public final fun component5 ()Ljava/util/List;
	public final fun component6 ()Ljava/lang/String;
	public final fun copy (ZIIDLjava/util/List;Ljava/lang/String;)Lsk/ainet/lang/tensor/ContiguityAnalysis;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/ContiguityAnalysis;ZIIDLjava/util/List;Ljava/lang/String;ILjava/lang/Object;)Lsk/ainet/lang/tensor/ContiguityAnalysis;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDimensionMatches ()Ljava/util/List;
	public final fun getParentVolume ()I
	public final fun getReason ()Ljava/lang/String;
	public final fun getViewVolume ()I
	public final fun getVolumeRatio ()D
	public fun hashCode ()I
	public final fun isContiguous ()Z
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/CopyMaterializationStrategy : sk/ainet/lang/tensor/MaterializationStrategy {
	public fun <init> ()V
	public fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public fun estimateMemoryOverhead (Lsk/ainet/lang/tensor/TensorView;)J
	public fun getName ()Ljava/lang/String;
	public fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
}

public class sk/ainet/lang/tensor/DefaultTensorViewStrategy : sk/ainet/lang/tensor/TensorViewStrategy {
	public fun <init> ()V
	public fun getDecisionReason (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Ljava/lang/String;
	public final fun getMaxStrideThreshold ()I
	public final fun getViewSizeThreshold ()D
	public final fun setMaxStrideThreshold (I)V
	public final fun setViewSizeThreshold (D)V
	public fun shouldCreateView (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Z
}

public abstract interface class sk/ainet/lang/tensor/IndexMapper {
	public abstract fun getStride ()[I
	public abstract fun isContiguous ()Z
	public abstract fun mapToParent ([I)[I
}

public final class sk/ainet/lang/tensor/LazyMaterializationStrategy : sk/ainet/lang/tensor/MaterializationStrategy {
	public fun <init> ()V
	public fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public fun estimateMemoryOverhead (Lsk/ainet/lang/tensor/TensorView;)J
	public final fun forceMaterialize (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun getName ()Ljava/lang/String;
	public fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/MaterializationExtensionsKt {
	public static final fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public static final fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;Lsk/ainet/lang/tensor/MaterializationStrategy;)Z
	public static final fun estimateMaterializationCost (Lsk/ainet/lang/tensor/TensorView;)J
	public static final fun estimateMaterializationCost (Lsk/ainet/lang/tensor/TensorView;Lsk/ainet/lang/tensor/MaterializationStrategy;)J
	public static final fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun materialize (Lsk/ainet/lang/tensor/TensorView;Lsk/ainet/lang/tensor/MaterializationStrategy;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/tensor/MaterializationStrategy {
	public abstract fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public abstract fun estimateMemoryOverhead (Lsk/ainet/lang/tensor/TensorView;)J
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/MemoryAwareTensorViewStrategy : sk/ainet/lang/tensor/DefaultTensorViewStrategy {
	public fun <init> ()V
	public fun getDecisionReason (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Ljava/lang/String;
	public final fun getMemoryPressureThreshold ()D
	public final fun getPressureViewSizeThreshold ()D
	public final fun setMemoryPressureThreshold (D)V
	public final fun setPressureViewSizeThreshold (D)V
	public fun shouldCreateView (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Z
}

public final class sk/ainet/lang/tensor/NCHWIndexMapper : sk/ainet/lang/tensor/IndexMapper {
	public fun <init> (Lsk/ainet/lang/tensor/Shape;Ljava/util/List;Lsk/ainet/lang/tensor/Shape;)V
	public fun getStride ()[I
	public fun isContiguous ()Z
	public fun mapToParent ([I)[I
}

public final class sk/ainet/lang/tensor/NCHWSlicePattern : java/lang/Enum {
	public static final field BATCH_SLICE Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field CHANNEL_SLICE Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field OTHER Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field SPATIAL_REGION Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field WIDTH_SLICE Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static fun values ()[Lsk/ainet/lang/tensor/NCHWSlicePattern;
}

public final class sk/ainet/lang/tensor/SegmentBuilder {
	public fun <init> (I)V
	public final fun all ()Lsk/ainet/lang/tensor/Slice;
	public final fun at (I)Lsk/ainet/lang/tensor/Slice;
	public final fun range (II)Lsk/ainet/lang/tensor/Slice;
	public final fun step (III)Lsk/ainet/lang/tensor/Slice;
	public final fun unaryMinus (Lkotlin/ranges/IntRange;)Lsk/ainet/lang/tensor/Slice;
	public final fun unaryPlus (Lkotlin/ranges/IntRange;)Lsk/ainet/lang/tensor/Slice;
}

public final class sk/ainet/lang/tensor/Shape {
	public static final field Companion Lsk/ainet/lang/tensor/Shape$Companion;
	public fun <init> ([I)V
	public final fun component1 ()[I
	public final fun copy ([I)Lsk/ainet/lang/tensor/Shape;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Shape;[IILjava/lang/Object;)Lsk/ainet/lang/tensor/Shape;
	public fun equals (Ljava/lang/Object;)Z
	public final fun get (I)I
	public final fun getDimensions ()[I
	public final fun getRank ()I
	public final fun getVolume ()I
	public fun hashCode ()I
	public final fun index ([I)I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Shape$Companion {
	public final fun invoke ([I)Lsk/ainet/lang/tensor/Shape;
}

public abstract class sk/ainet/lang/tensor/Slice {
	public final fun getResultSize (I)I
	public final fun hasNonTrivialStride ()Z
	public final fun isContiguous ()Z
	public final fun isEmpty ()Z
	public final fun isValid (I)Z
	public final fun normalize (I)Lsk/ainet/lang/tensor/Slice;
}

public final class sk/ainet/lang/tensor/Slice$All : sk/ainet/lang/tensor/Slice {
	public fun <init> ()V
	public fun equals (Ljava/lang/Object;)Z
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Slice$At : sk/ainet/lang/tensor/Slice {
	public fun <init> (I)V
	public final fun component1 ()I
	public final fun copy (I)Lsk/ainet/lang/tensor/Slice$At;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Slice$At;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Slice$At;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getIndex ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Slice$Range : sk/ainet/lang/tensor/Slice {
	public fun <init> (II)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun copy (II)Lsk/ainet/lang/tensor/Slice$Range;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Slice$Range;IIILjava/lang/Object;)Lsk/ainet/lang/tensor/Slice$Range;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getEnd ()I
	public final fun getStart ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Slice$Step : sk/ainet/lang/tensor/Slice {
	public fun <init> (III)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun component3 ()I
	public final fun copy (III)Lsk/ainet/lang/tensor/Slice$Step;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Slice$Step;IIIILjava/lang/Object;)Lsk/ainet/lang/tensor/Slice$Step;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getEnd ()I
	public final fun getStart ()I
	public final fun getStep ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/SliceIndexMapper : sk/ainet/lang/tensor/IndexMapper {
	public fun <init> (Lsk/ainet/lang/tensor/Shape;Ljava/util/List;Lsk/ainet/lang/tensor/Shape;)V
	public final fun canVectorize ()Z
	public final fun getAccessPattern ()Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public fun getStride ()[I
	public fun isContiguous ()Z
	public fun mapToParent ([I)[I
}

public final class sk/ainet/lang/tensor/SliceIndexMapper$AccessPattern : java/lang/Enum {
	public static final field CONTIGUOUS_COMPLEX Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static final field CONTIGUOUS_SIMPLE Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static final field NON_CONTIGUOUS Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static fun values ()[Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
}

public final class sk/ainet/lang/tensor/SlicedTensorView : sk/ainet/lang/tensor/TensorView {
	public fun <init> (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)V
	public fun getData ()Lsk/ainet/lang/tensor/data/TensorData;
	public fun getDtype ()Lsk/ainet/lang/types/DType;
	public fun getIndexMapping ()Lsk/ainet/lang/tensor/IndexMapper;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getParentTensor ()Lsk/ainet/lang/tensor/Tensor;
	public fun getRank ()I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public final fun getSliceOperations ()Ljava/util/List;
	public fun getViewShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getVolume ()I
}

public abstract interface class sk/ainet/lang/tensor/Tensor {
	public abstract fun getData ()Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun getDtype ()Lsk/ainet/lang/types/DType;
	public abstract fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getRank ()I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getVolume ()I
}

public final class sk/ainet/lang/tensor/Tensor$DefaultImpls {
	public static fun getRank (Lsk/ainet/lang/tensor/Tensor;)I
	public static fun getShape (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Shape;
	public static fun getVolume (Lsk/ainet/lang/tensor/Tensor;)I
}

public final class sk/ainet/lang/tensor/TensorSliceBuilder {
	public fun <init> ()V
	public final fun segment (Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ainet/lang/tensor/TensorSlicingExtensionsKt {
	public static final fun detectNCHWSlicePattern (Ljava/util/List;)Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final fun isContiguousSlice (Ljava/util/List;)Z
	public static final fun slice (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceAt (Lsk/ainet/lang/tensor/Tensor;[I)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceCopy (Lsk/ainet/lang/tensor/Tensor;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun sliceRanges (Lsk/ainet/lang/tensor/Tensor;[Lkotlin/Pair;)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceView (Lsk/ainet/lang/tensor/Tensor;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceView (Lsk/ainet/lang/tensor/TensorView;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/TensorView;
}

public abstract interface class sk/ainet/lang/tensor/TensorView : sk/ainet/lang/tensor/Tensor {
	public abstract fun getIndexMapping ()Lsk/ainet/lang/tensor/IndexMapper;
	public abstract fun getParentTensor ()Lsk/ainet/lang/tensor/Tensor;
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public abstract fun getViewShape ()Lsk/ainet/lang/tensor/Shape;
}

public final class sk/ainet/lang/tensor/TensorView$DefaultImpls {
	public static fun getRank (Lsk/ainet/lang/tensor/TensorView;)I
	public static fun getShape (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Shape;
	public static fun getVolume (Lsk/ainet/lang/tensor/TensorView;)I
}

public abstract interface class sk/ainet/lang/tensor/TensorViewStrategy {
	public abstract fun getDecisionReason (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Ljava/lang/String;
	public abstract fun shouldCreateView (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Z
}

public final class sk/ainet/lang/tensor/TesnorExtKt {
	public static final fun isMatrix (Lsk/ainet/lang/tensor/Tensor;)Z
	public static final fun isScalar (Lsk/ainet/lang/tensor/Tensor;)Z
	public static final fun isVector (Lsk/ainet/lang/tensor/Tensor;)Z
}

public final class sk/ainet/lang/tensor/ViewManagementExtensionsKt {
	public static final fun analyzeContiguity (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/ContiguityAnalysis;
	public static final fun batchMaterialize (Ljava/util/List;)Ljava/util/List;
	public static final fun batchMaterialize (Ljava/util/List;Lsk/ainet/lang/tensor/MaterializationStrategy;)Ljava/util/List;
	public static final fun estimateBatchMaterializationCost (Ljava/util/List;)J
	public static final fun estimateBatchMaterializationCost (Ljava/util/List;Lsk/ainet/lang/tensor/MaterializationStrategy;)J
	public static final fun isContiguous (Lsk/ainet/lang/tensor/TensorView;)Z
}

public final class sk/ainet/lang/tensor/benchmark/BenchmarkConfig {
	public fun <init> ()V
	public fun <init> (IILjava/util/List;Z)V
	public synthetic fun <init> (IILjava/util/List;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun component3 ()Ljava/util/List;
	public final fun component4 ()Z
	public final fun copy (IILjava/util/List;Z)Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;IILjava/util/List;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getIncludeMemoryBenchmarks ()Z
	public final fun getIterations ()I
	public final fun getTensorShapes ()Ljava/util/List;
	public final fun getWarmupIterations ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/benchmark/BenchmarkReporter {
	public fun <init> ()V
	public final fun compareResults (Ljava/util/List;Ljava/util/List;)Ljava/lang/String;
	public final fun generateReport (Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;
	public static synthetic fun generateReport$default (Lsk/ainet/lang/tensor/benchmark/BenchmarkReporter;Ljava/util/List;Ljava/lang/String;ILjava/lang/Object;)Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/benchmark/BenchmarkResult {
	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Ljava/lang/String;
	public final fun component3 ()Ljava/lang/String;
	public final fun component4-UwyO8pc ()J
	public final fun component5 ()Ljava/lang/Long;
	public final fun component6 ()Ljava/lang/Double;
	public final fun copy-gwCluXo (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;)Lsk/ainet/lang/tensor/benchmark/BenchmarkResult;
	public static synthetic fun copy-gwCluXo$default (Lsk/ainet/lang/tensor/benchmark/BenchmarkResult;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;ILjava/lang/Object;)Lsk/ainet/lang/tensor/benchmark/BenchmarkResult;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDuration-UwyO8pc ()J
	public final fun getMemoryUsage ()Ljava/lang/Long;
	public final fun getOperationType ()Ljava/lang/String;
	public final fun getSlicePattern ()Ljava/lang/String;
	public final fun getTensorSize ()Ljava/lang/String;
	public final fun getThroughput ()Ljava/lang/Double;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite {
	public fun <init> ()V
	public final fun benchmarkAccessPatterns (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;)Ljava/util/List;
	public static synthetic fun benchmarkAccessPatterns$default (Lsk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;ILjava/lang/Object;)Ljava/util/List;
	public final fun benchmarkMLScenarios (Lkotlin/jvm/functions/Function1;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;)Ljava/util/List;
	public static synthetic fun benchmarkMLScenarios$default (Lsk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite;Lkotlin/jvm/functions/Function1;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;ILjava/lang/Object;)Ljava/util/List;
	public final fun benchmarkViewVsCopy (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;)Ljava/util/List;
	public static synthetic fun benchmarkViewVsCopy$default (Lsk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;ILjava/lang/Object;)Ljava/util/List;
}

public abstract interface class sk/ainet/lang/tensor/data/ItemsAccessor {
	public abstract fun get ([I)Ljava/lang/Object;
	public abstract fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/PprintKt {
	public static final fun pprint (Lsk/ainet/lang/tensor/data/TensorData;)Ljava/lang/String;
}

public abstract interface class sk/ainet/lang/tensor/data/TensorData : sk/ainet/lang/tensor/data/ItemsAccessor {
	public static final field Companion Lsk/ainet/lang/tensor/data/TensorData$Companion;
	public abstract fun getShape ()Lsk/ainet/lang/tensor/Shape;
}

public final class sk/ainet/lang/tensor/data/TensorData$Companion {
}

public final class sk/ainet/lang/tensor/dsl/ConvKernel {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun conv3x3 (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun conv5x5 (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun oihw (IIII)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun pointwise (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun square (III)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
}

public final class sk/ainet/lang/tensor/dsl/ImageExtensionsKt {
	public static final fun image (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/ImageTensor;
	public static final fun imageInit (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;)Lsk/ainet/lang/tensor/dsl/ImageInitializers;
	public static final fun kernel (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/ConvKernel;
}

public final class sk/ainet/lang/tensor/dsl/ImageInitializers {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;)V
	public final fun black ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun imagenetNormalized (Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun imagenetNormalized$default (Lsk/ainet/lang/tensor/dsl/ImageInitializers;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun normalizedPixels (Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun normalizedPixels$default (Lsk/ainet/lang/tensor/dsl/ImageInitializers;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun pixelRange (Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun pixelRange$default (Lsk/ainet/lang/tensor/dsl/ImageInitializers;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun white ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/ImageTensor {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun bchw (IIII)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun chw (III)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun grayscale (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun rgb (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun rgba (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
}

public abstract class sk/ainet/lang/tensor/dsl/InitializationType {
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Custom : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (Lkotlin/jvm/functions/Function1;)V
	public final fun component1 ()Lkotlin/jvm/functions/Function1;
	public final fun copy (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/dsl/InitializationType$Custom;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Custom;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Custom;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getGenerator ()Lkotlin/jvm/functions/Function1;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Fill : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (Ljava/lang/Number;)V
	public final fun component1 ()Ljava/lang/Number;
	public final fun copy (Ljava/lang/Number;)Lsk/ainet/lang/tensor/dsl/InitializationType$Fill;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Fill;Ljava/lang/Number;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Fill;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getValue ()Ljava/lang/Number;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Normal : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (FFLkotlin/random/Random;)V
	public final fun component1 ()F
	public final fun component2 ()F
	public final fun component3 ()Lkotlin/random/Random;
	public final fun copy (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/InitializationType$Normal;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Normal;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Normal;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getMean ()F
	public final fun getRandom ()Lkotlin/random/Random;
	public final fun getStd ()F
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Ones : sk/ainet/lang/tensor/dsl/InitializationType {
	public static final field INSTANCE Lsk/ainet/lang/tensor/dsl/InitializationType$Ones;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$RandomCustom : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)V
	public final fun component1 ()Lkotlin/jvm/functions/Function1;
	public final fun component2 ()Lkotlin/random/Random;
	public final fun copy (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/InitializationType$RandomCustom;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$RandomCustom;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$RandomCustom;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getGenerator ()Lkotlin/jvm/functions/Function1;
	public final fun getRandom ()Lkotlin/random/Random;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Uniform : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (FFLkotlin/random/Random;)V
	public final fun component1 ()F
	public final fun component2 ()F
	public final fun component3 ()Lkotlin/random/Random;
	public final fun copy (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/InitializationType$Uniform;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Uniform;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Uniform;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getMax ()F
	public final fun getMin ()F
	public final fun getRandom ()Lkotlin/random/Random;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Zeros : sk/ainet/lang/tensor/dsl/InitializationType {
	public static final field INSTANCE Lsk/ainet/lang/tensor/dsl/InitializationType$Zeros;
}

public final class sk/ainet/lang/tensor/dsl/MLPBias {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun constant (ILjava/lang/Number;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun normal (IFFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun normal$default (Lsk/ainet/lang/tensor/dsl/MLPBias;IFFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun ones (I)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun zeros (I)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/MLPExtensionsKt {
	public static final fun bias (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/MLPBias;
	public static final fun weights (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/MLPWeights;
}

public final class sk/ainet/lang/tensor/dsl/MLPWeights {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun he (IILkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun he$default (Lsk/ainet/lang/tensor/dsl/MLPWeights;IILkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun normal (IIFFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun normal$default (Lsk/ainet/lang/tensor/dsl/MLPWeights;IIFFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun ones (II)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun xavier (IILkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun xavier$default (Lsk/ainet/lang/tensor/dsl/MLPWeights;IILkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun zeros (II)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/ShapeBuilder {
	public fun <init> (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/tensor/Shape;)V
	public final fun fill (Ljava/lang/Number;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun init (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun ones ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun randn (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun randn$default (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun randomInit (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun randomInit$default (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun uniform (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun uniform$default (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun zeros ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/TensorBuilder {
	public fun <init> (Lsk/ainet/lang/types/DType;)V
	public final fun shape (Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun shape ([I)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
}

public final class sk/ainet/lang/tensor/dsl/TensorDSLKt {
	public static final fun tensor (Lsk/ainet/lang/tensor/dsl/TensorDataFactory;[ILkotlin/jvm/functions/Function2;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun tensor (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/dsl/TensorBuilder;
}

public abstract interface class sk/ainet/lang/tensor/dsl/TensorDataFactory {
	public abstract fun full (Lsk/ainet/lang/tensor/Shape;Ljava/lang/Number;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun init (Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/types/DType;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun ones (Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun randn (Lsk/ainet/lang/tensor/Shape;FFLsk/ainet/lang/types/DType;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun randomInit (Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/types/DType;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun uniform (Lsk/ainet/lang/tensor/Shape;FFLsk/ainet/lang/types/DType;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun zeros (Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
}

public final class sk/ainet/lang/tensor/dsl/TensorInitializer {
	public fun <init> (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/tensor/dsl/InitializationType;)V
	public final fun build (Lsk/ainet/lang/tensor/dsl/TensorDataFactory;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/ops/SimpleTensorOperation : sk/ainet/lang/tensor/ops/TensorOps {
	public fun <init> ()V
}

public abstract interface class sk/ainet/lang/tensor/ops/TensorOps {
}

public abstract interface class sk/ainet/lang/types/DType {
	public static final field Companion Lsk/ainet/lang/types/DType$Companion;
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun getSizeInBits ()I
	public abstract fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public abstract fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/DType$Companion {
	public final fun findByName (Ljava/lang/String;)Lsk/ainet/lang/types/DType;
	public final fun getAllTypes ()Ljava/util/Map;
}

public final class sk/ainet/lang/types/DTypeExtensionsKt {
	public static final fun kotlinClass (Lsk/ainet/lang/types/DType;)Lkotlin/reflect/KClass;
}

public final class sk/ainet/lang/types/FP16 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/FP16;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/FP32 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/FP32;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Int32 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Int32;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Int4 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Int4;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Int8 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Int8;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Ternary : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Ternary;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/TypeUtils {
	public static final field INSTANCE Lsk/ainet/lang/types/TypeUtils;
	public final fun areAllCompatible (Ljava/util/Collection;)Z
	public final fun areAllCompatible ([Lsk/ainet/lang/types/DType;)Z
	public final fun debugAllTypes ()V
	public final fun describe (Lsk/ainet/lang/types/DType;)Ljava/lang/String;
	public final fun findCommonType (Ljava/util/Collection;)Lsk/ainet/lang/types/DType;
	public final fun findCommonType ([Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
	public final fun getTypeByName (Ljava/lang/String;)Lsk/ainet/lang/types/DType;
	public final fun isValidTypeName (Ljava/lang/String;)Z
	public final fun promote (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/TypeUtils$TypePromotionBuilder;
}

public final class sk/ainet/lang/types/TypeUtils$TypePromotionBuilder {
	public fun <init> (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)V
	public final fun getResultType ()Lsk/ainet/lang/types/DType;
	public final fun getResultTypeOrNull ()Lsk/ainet/lang/types/DType;
	public final fun isCompatible ()Z
}

