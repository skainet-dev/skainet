= Data Processing Use Cases
:toc: left
:toclevels: 3
:sectanchors:
:sectlinks:

Explore practical data processing scenarios using SKaiNET for real-world applications in machine learning and scientific computing.

== Image Processing

=== Image Filtering and Convolutions

Apply filters to images for feature extraction and preprocessing:

[source,kotlin]
----
// Create common image processing kernels
object ImageKernels {
    
    fun gaussianBlur(): CpuTensorFP32 {
        return CpuTensorFP32.fromArray(
            Shape(3, 3),
            floatArrayOf(
                1f/16f, 2f/16f, 1f/16f,
                2f/16f, 4f/16f, 2f/16f,
                1f/16f, 2f/16f, 1f/16f
            )
        )
    }
    
    fun edgeDetectionSobel(): CpuTensorFP32 {
        return CpuTensorFP32.fromArray(
            Shape(3, 3),
            floatArrayOf(
                -1f, 0f, 1f,
                -2f, 0f, 2f,
                -1f, 0f, 1f
            )
        )
    }
    
    fun sharpen(): CpuTensorFP32 {
        return CpuTensorFP32.fromArray(
            Shape(3, 3),
            floatArrayOf(
                0f, -1f, 0f,
                -1f, 5f, -1f,
                0f, -1f, 0f
            )
        )
    }
}

// Apply convolution to image
fun applyConvolution(
    image: CpuTensorFP32,
    kernel: CpuTensorFP32,
    backend: CpuBackend
): CpuTensorFP32 {
    val height = image.shape.dimensions[0]
    val width = image.shape.dimensions[1]
    val resultHeight = height - 2
    val resultWidth = width - 2
    
    val result = FloatArray(resultHeight * resultWidth)
    
    for (i in 0 until resultHeight) {
        for (j in 0 until resultWidth) {
            var sum = 0f
            
            // Apply kernel
            for (ki in 0 until 3) {
                for (kj in 0 until 3) {
                    sum += image[i + ki, j + kj] * kernel[ki, kj]
                }
            }
            
            result[i * resultWidth + j] = sum
        }
    }
    
    return CpuTensorFP32.fromArray(Shape(resultHeight, resultWidth), result)
}

// Example: Process a sample image
val backend = CpuBackend()

// Create a sample 8x8 grayscale image
val sampleImage = CpuTensorFP32.fromArray(
    Shape(8, 8),
    FloatArray(64) { i ->
        val row = i / 8
        val col = i % 8
        // Create a simple pattern
        if (row < 4 && col < 4) 255f else 0f
    }
)

// Apply different filters
val blurred = applyConvolution(sampleImage, ImageKernels.gaussianBlur(), backend)
val edges = applyConvolution(sampleImage, ImageKernels.edgeDetectionSobel(), backend)
val sharpened = applyConvolution(sampleImage, ImageKernels.sharpen(), backend)

println("Original image shape: ${sampleImage.shape}")
println("Processed image shape: ${blurred.shape}")
----

=== Image Normalization and Preprocessing

Prepare images for machine learning models:

[source,kotlin]
----
class ImagePreprocessor(val backend: CpuBackend) {
    
    // Normalize image to [0, 1] range
    fun normalizeToUnitRange(image: CpuTensorFP32): CpuTensorFP32 {
        val shape = image.shape
        
        // Find min and max values
        var minVal = Float.MAX_VALUE
        var maxVal = Float.MIN_VALUE
        
        for (i in 0 until shape.dimensions[0]) {
            for (j in 0 until shape.dimensions[1]) {
                val value = image[i, j]
                if (value < minVal) minVal = value
                if (value > maxVal) maxVal = value
            }
        }
        
        val range = maxVal - minVal
        
        return if (range > 0f) {
            with(backend) {
                (image - minVal) / range
            }
        } else {
            image
        }
    }
    
    // Standardize image (zero mean, unit variance)
    fun standardize(image: CpuTensorFP32): CpuTensorFP32 {
        val shape = image.shape
        val totalPixels = shape.size
        
        // Calculate mean
        var sum = 0f
        for (i in 0 until shape.dimensions[0]) {
            for (j in 0 until shape.dimensions[1]) {
                sum += image[i, j]
            }
        }
        val mean = sum / totalPixels
        
        // Calculate standard deviation
        var varianceSum = 0f
        for (i in 0 until shape.dimensions[0]) {
            for (j in 0 until shape.dimensions[1]) {
                val diff = image[i, j] - mean
                varianceSum += diff * diff
            }
        }
        val stdDev = kotlin.math.sqrt(varianceSum / totalPixels)
        
        return if (stdDev > 0f) {
            with(backend) {
                (image - mean) / stdDev
            }
        } else {
            with(backend) {
                image - mean
            }
        }
    }
    
    // Resize image using nearest neighbor (simplified)
    fun resize(image: CpuTensorFP32, newHeight: Int, newWidth: Int): CpuTensorFP32 {
        val oldHeight = image.shape.dimensions[0]
        val oldWidth = image.shape.dimensions[1]
        
        val result = FloatArray(newHeight * newWidth) { i ->
            val newRow = i / newWidth
            val newCol = i % newWidth
            
            val oldRow = (newRow * oldHeight) / newHeight
            val oldCol = (newCol * oldWidth) / newWidth
            
            image[oldRow, oldCol]
        }
        
        return CpuTensorFP32.fromArray(Shape(newHeight, newWidth), result)
    }
}

// Example usage
val preprocessor = ImagePreprocessor(backend)
val rawImage = CpuTensorFP32.fromArray(
    Shape(4, 4),
    floatArrayOf(
        100f, 120f, 110f, 130f,
        90f,  140f, 125f, 135f,
        95f,  115f, 105f, 145f,
        85f,  155f, 150f, 160f
    )
)

val normalized = preprocessor.normalizeToUnitRange(rawImage)
val standardized = preprocessor.standardize(rawImage)
val resized = preprocessor.resize(rawImage, 8, 8)

println("Original shape: ${rawImage.shape}")
println("Resized shape: ${resized.shape}")
----

== Time Series Processing

=== Signal Filtering and Smoothing

Process temporal data for analysis and prediction:

[source,kotlin]
----
class TimeSeriesProcessor(val backend: CpuBackend) {
    
    // Simple moving average filter
    fun movingAverage(series: CpuTensorFP32, windowSize: Int): CpuTensorFP32 {
        val length = series.shape.dimensions[0]
        val resultLength = length - windowSize + 1
        val result = FloatArray(resultLength)
        
        for (i in 0 until resultLength) {
            var sum = 0f
            for (j in 0 until windowSize) {
                sum += series[i + j]
            }
            result[i] = sum / windowSize
        }
        
        return CpuTensorFP32.fromArray(Shape(resultLength), result)
    }
    
    // Exponential moving average
    fun exponentialMovingAverage(series: CpuTensorFP32, alpha: Float): CpuTensorFP32 {
        val length = series.shape.dimensions[0]
        val result = FloatArray(length)
        
        result[0] = series[0]
        
        for (i in 1 until length) {
            result[i] = alpha * series[i] + (1 - alpha) * result[i - 1]
        }
        
        return CpuTensorFP32.fromArray(Shape(length), result)
    }
    
    // Difference the series (for stationarity)
    fun difference(series: CpuTensorFP32, order: Int = 1): CpuTensorFP32 {
        var current = series
        
        repeat(order) {
            val length = current.shape.dimensions[0]
            val result = FloatArray(length - 1)
            
            for (i in 0 until length - 1) {
                result[i] = current[i + 1] - current[i]
            }
            
            current = CpuTensorFP32.fromArray(Shape(result.size), result)
        }
        
        return current
    }
    
    // Create lagged features for prediction
    fun createLaggedFeatures(series: CpuTensorFP32, numLags: Int): CpuTensorFP32 {
        val length = series.shape.dimensions[0]
        val resultLength = length - numLags
        val result = FloatArray(resultLength * numLags)
        
        for (i in 0 until resultLength) {
            for (lag in 0 until numLags) {
                result[i * numLags + lag] = series[i + lag]
            }
        }
        
        return CpuTensorFP32.fromArray(Shape(resultLength, numLags), result)
    }
}

// Example: Stock price analysis
val processor = TimeSeriesProcessor(backend)

// Simulate stock prices
val stockPrices = CpuTensorFP32.fromArray(
    Shape(50),
    FloatArray(50) { i ->
        100f + 10f * kotlin.math.sin(i * 0.2f) + kotlin.random.Random.nextGaussian().toFloat() * 2f
    }
)

val smoothed = processor.movingAverage(stockPrices, 5)
val ema = processor.exponentialMovingAverage(stockPrices, 0.3f)
val differenced = processor.difference(stockPrices)
val laggedFeatures = processor.createLaggedFeatures(stockPrices, 3)

println("Original series length: ${stockPrices.shape.dimensions[0]}")
println("Smoothed series length: ${smoothed.shape.dimensions[0]}")
println("Lagged features shape: ${laggedFeatures.shape}")
----

== Natural Language Processing (Text Processing)

=== Text Vectorization

Convert text to numerical representations:

[source,kotlin]
----
class TextVectorizer {
    
    // Simple bag-of-words representation
    fun createVocabulary(texts: List<String>): Map<String, Int> {
        val vocabulary = mutableMapOf<String, Int>()
        var index = 0
        
        texts.forEach { text ->
            text.lowercase()
                .split(Regex("\\s+"))
                .forEach { word ->
                    if (word.isNotEmpty() && !vocabulary.containsKey(word)) {
                        vocabulary[word] = index++
                    }
                }
        }
        
        return vocabulary
    }
    
    // Convert text to bag-of-words vector
    fun textToBagOfWords(text: String, vocabulary: Map<String, Int>): CpuTensorFP32 {
        val vector = FloatArray(vocabulary.size) { 0f }
        
        text.lowercase()
            .split(Regex("\\s+"))
            .forEach { word ->
                vocabulary[word]?.let { index ->
                    vector[index] += 1f
                }
            }
        
        return CpuTensorFP32.fromArray(Shape(vocabulary.size), vector)
    }
    
    // TF-IDF calculation (simplified)
    fun calculateTfIdf(
        texts: List<String>, 
        vocabulary: Map<String, Int>
    ): List<CpuTensorFP32> {
        val numDocs = texts.size
        
        // Calculate document frequency for each word
        val documentFreq = FloatArray(vocabulary.size) { 0f }
        
        texts.forEach { text ->
            val wordsInDoc = text.lowercase().split(Regex("\\s+")).toSet()
            wordsInDoc.forEach { word ->
                vocabulary[word]?.let { index ->
                    documentFreq[index] += 1f
                }
            }
        }
        
        return texts.map { text ->
            val words = text.lowercase().split(Regex("\\s+"))
            val termFreq = FloatArray(vocabulary.size) { 0f }
            
            // Calculate term frequency
            words.forEach { word ->
                vocabulary[word]?.let { index ->
                    termFreq[index] += 1f
                }
            }
            
            // Calculate TF-IDF
            val tfidf = FloatArray(vocabulary.size) { i ->
                val tf = termFreq[i] / words.size
                val idf = kotlin.math.ln(numDocs.toFloat() / (documentFreq[i] + 1f))
                tf * idf
            }
            
            CpuTensorFP32.fromArray(Shape(vocabulary.size), tfidf)
        }
    }
}

// Example: Document classification preprocessing
val vectorizer = TextVectorizer()

val documents = listOf(
    "machine learning is powerful",
    "deep learning neural networks",
    "artificial intelligence algorithms",
    "data science and analytics",
    "computer vision applications"
)

val vocabulary = vectorizer.createVocabulary(documents)
val bagOfWordsVectors = documents.map { doc ->
    vectorizer.textToBagOfWords(doc, vocabulary)
}
val tfidfVectors = vectorizer.calculateTfIdf(documents, vocabulary)

println("Vocabulary size: ${vocabulary.size}")
println("Document vector shape: ${bagOfWordsVectors[0].shape}")
println("Sample vocabulary: ${vocabulary.keys.take(10)}")
----

== Batch Data Processing

=== Efficient Batch Operations

Process large datasets efficiently using tensor batching:

[source,kotlin]
----
class BatchProcessor(val backend: CpuBackend) {
    
    // Process data in batches
    fun <T> processBatches(
        data: List<T>,
        batchSize: Int,
        processor: (List<T>) -> CpuTensorFP32
    ): List<CpuTensorFP32> {
        return data.chunked(batchSize).map { batch ->
            processor(batch)
        }
    }
    
    // Stack multiple tensors into a batch tensor
    fun stackTensors(tensors: List<CpuTensorFP32>): CpuTensorFP32 {
        if (tensors.isEmpty()) {
            throw IllegalArgumentException("Cannot stack empty list of tensors")
        }
        
        val batchSize = tensors.size
        val sampleShape = tensors[0].shape
        val batchShape = Shape(batchSize, *sampleShape.dimensions)
        
        val batchData = FloatArray(batchSize * sampleShape.size) { i ->
            val sampleIndex = i / sampleShape.size
            val elementIndex = i % sampleShape.size
            
            // Convert flat index to coordinates for the sample
            val coords = IntArray(sampleShape.rank)
            var remaining = elementIndex
            for (j in sampleShape.rank - 1 downTo 0) {
                coords[j] = remaining % sampleShape.dimensions[j]
                remaining /= sampleShape.dimensions[j]
            }
            
            tensors[sampleIndex][*coords]
        }
        
        return CpuTensorFP32.fromArray(batchShape, batchData)
    }
    
    // Apply normalization to entire batch
    fun batchNormalize(batch: CpuTensorFP32): CpuTensorFP32 {
        val batchSize = batch.shape.dimensions[0]
        val featureSize = batch.shape.dimensions[1]
        
        // Calculate mean and std across batch
        val means = FloatArray(featureSize) { feature ->
            var sum = 0f
            for (sample in 0 until batchSize) {
                sum += batch[sample, feature]
            }
            sum / batchSize
        }
        
        val stds = FloatArray(featureSize) { feature ->
            var varianceSum = 0f
            for (sample in 0 until batchSize) {
                val diff = batch[sample, feature] - means[feature]
                varianceSum += diff * diff
            }
            kotlin.math.sqrt(varianceSum / batchSize)
        }
        
        // Normalize
        val normalized = FloatArray(batchSize * featureSize) { i ->
            val sample = i / featureSize
            val feature = i % featureSize
            val value = batch[sample, feature]
            if (stds[feature] > 0f) {
                (value - means[feature]) / stds[feature]
            } else {
                value - means[feature]
            }
        }
        
        return CpuTensorFP32.fromArray(batch.shape, normalized)
    }
}

// Example: Process dataset in batches
val processor = BatchProcessor(backend)

// Simulate a dataset of feature vectors
val dataset = List(100) { i ->
    CpuTensorFP32.fromArray(
        Shape(5),
        FloatArray(5) { kotlin.random.Random.nextGaussian().toFloat() + i * 0.1f }
    )
}

// Stack into batches and process
val batchSize = 16
val batches = dataset.chunked(batchSize).map { batch ->
    processor.stackTensors(batch)
}

println("Dataset size: ${dataset.size}")
println("Number of batches: ${batches.size}")
println("Batch shape: ${batches[0].shape}")

// Apply batch normalization
val normalizedBatches = batches.map { batch ->
    processor.batchNormalize(batch)
}

println("Normalized batch shape: ${normalizedBatches[0].shape}")
----

== Data Augmentation

=== Image Data Augmentation

Increase dataset size and improve model robustness:

[source,kotlin]
----
class DataAugmenter(val backend: CpuBackend) {
    
    // Add random noise to image
    fun addNoise(image: CpuTensorFP32, noiseLevel: Float): CpuTensorFP32 {
        val shape = image.shape
        val noisy = FloatArray(shape.size) { i ->
            val coords = IntArray(shape.rank)
            var remaining = i
            for (j in shape.rank - 1 downTo 0) {
                coords[j] = remaining % shape.dimensions[j]
                remaining /= shape.dimensions[j]
            }
            
            val originalValue = image[*coords]
            val noise = kotlin.random.Random.nextGaussian().toFloat() * noiseLevel
            originalValue + noise
        }
        
        return CpuTensorFP32.fromArray(shape, noisy)
    }
    
    // Horizontal flip
    fun horizontalFlip(image: CpuTensorFP32): CpuTensorFP32 {
        val height = image.shape.dimensions[0]
        val width = image.shape.dimensions[1]
        
        val flipped = FloatArray(height * width) { i ->
            val row = i / width
            val col = i % width
            val flippedCol = width - 1 - col
            image[row, flippedCol]
        }
        
        return CpuTensorFP32.fromArray(image.shape, flipped)
    }
    
    // Brightness adjustment
    fun adjustBrightness(image: CpuTensorFP32, factor: Float): CpuTensorFP32 {
        return with(backend) {
            image * factor
        }
    }
    
    // Generate multiple augmented versions
    fun augmentImage(image: CpuTensorFP32, numAugmentations: Int): List<CpuTensorFP32> {
        val augmented = mutableListOf<CpuTensorFP32>()
        
        repeat(numAugmentations) {
            var current = image
            
            // Random horizontal flip
            if (kotlin.random.Random.nextBoolean()) {
                current = horizontalFlip(current)
            }
            
            // Random brightness adjustment
            val brightnessFactor = 0.8f + kotlin.random.Random.nextFloat() * 0.4f
            current = adjustBrightness(current, brightnessFactor)
            
            // Random noise
            if (kotlin.random.Random.nextFloat() < 0.3f) {
                current = addNoise(current, 0.05f)
            }
            
            augmented.add(current)
        }
        
        return augmented
    }
}

// Example: Augment training data
val augmenter = DataAugmenter(backend)

val originalImage = CpuTensorFP32.fromArray(
    Shape(8, 8),
    FloatArray(64) { i ->
        val row = i / 8
        val col = i % 8
        if ((row + col) % 2 == 0) 1f else 0f
    }
)

val augmentedImages = augmenter.augmentImage(originalImage, 5)

println("Original image shape: ${originalImage.shape}")
println("Generated ${augmentedImages.size} augmented versions")
----

== Performance Tips for Data Processing

=== Memory Efficient Processing

[source,kotlin]
----
// Process data in chunks to manage memory
fun processLargeDataset(
    dataLoader: () -> List<CpuTensorFP32>,
    chunkSize: Int,
    processor: (CpuTensorFP32) -> CpuTensorFP32
): List<CpuTensorFP32> {
    val results = mutableListOf<CpuTensorFP32>()
    val data = dataLoader()
    
    data.chunked(chunkSize).forEach { chunk ->
        // Process chunk and collect results
        chunk.forEach { sample ->
            results.add(processor(sample))
        }
        
        // Optional: trigger garbage collection between chunks
        System.gc()
    }
    
    return results
}
----

== Next Steps

With data processing mastered, you now have all the tools needed to build complete machine learning pipelines with SKaiNET. Consider exploring xref:performance-tips.adoc[Performance Tips] for optimizing your implementations.

[TIP]
====
Data processing is often the most time-consuming part of machine learning projects. Efficient preprocessing and augmentation pipelines can significantly improve both training speed and model performance.
====